<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vue3 Chat WebView</title>
    <!-- Vue 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: transparent !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        #app {
            min-height: 100vh; /* æœ€å°é«˜åº¦ï¼Œå…è®¸å†…å®¹è¶…å‡ºæ—¶æ»šåŠ¨ */
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* å†…å®¹ä»åº•éƒ¨å¼€å§‹ */
            padding: 8px;
            box-sizing: border-box;
            color: inherit; /* ç¡®ä¿ç»§æ‰¿é¢œè‰² */
            background: transparent !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        .chat-container {
            display: flex;
            flex-direction: column-reverse; /* åè½¬åˆ—è¡¨ï¼Œæœ€æ–°æ¶ˆæ¯åœ¨åº•éƒ¨ */
            gap: 8px;
            max-width: 100%;
        }
        
        .message-item {
            display: flex;
            flex-direction: column;
        }
        
        .message-item.user {
            align-items: flex-end;
        }
        
        .message-item.ai {
            align-items: flex-start;
        }
        
        .message-bubble {
            max-width: 100%;
            min-width: fit-content;
            padding: 8px 12px;
            border-radius: 10px;
            word-wrap: break-word;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: block;
            width: auto;
        }


        
        .message-content {
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* æ¶ˆæ¯å†…å®¹ç»§æ‰¿æ°”æ³¡é¢œè‰² */
        .message-content {
            color: inherit;
        }

        /* æ··åˆå†…å®¹ä¹Ÿç»§æ‰¿æ°”æ³¡é¢œè‰²ï¼Œä½†å…è®¸HTMLæ ‡ç­¾è¦†ç›– */
        .mixed-content {
            color: inherit;
        }
        
        .message-actions {
            margin-top: 8px;
            display: flex;
            align-items: flex-start; /* ç»Ÿä¸€é¡¶éƒ¨å¯¹é½ */
            gap: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
            min-height: 28px; /* ç¡®ä¿æŠ˜å å’Œå±•å¼€çŠ¶æ€é«˜åº¦ä¸€è‡´ */
        }

        /* ç”¨æˆ·æ¶ˆæ¯çš„æ“ä½œæŒ‰é’®å³å¯¹é½ */
        .message-item.user .message-actions {
            justify-content: flex-end;
        }

        /* AIæ¶ˆæ¯çš„æ“ä½œæŒ‰é’®å·¦å¯¹é½ */
        .message-item.ai .message-actions {
            justify-content: flex-start;
        }

        .actions-collapsed {
            width: auto;
        }

        .actions-expanded {
            width: 100%;
        }

        .function-btn {
            padding: 2px 6px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 9px;
            background: rgba(0, 0, 0, 0.1);
            color: #666;
            transition: all 0.2s;
            height: 20px;
            box-sizing: border-box;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .function-btn:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        .expanded-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* AIæ¶ˆæ¯å±•å¼€åçš„æŒ‰é’®å·¦å¯¹é½ */
        .message-item.ai .expanded-actions {
            justify-content: flex-start;
        }

        /* ç”¨æˆ·æ¶ˆæ¯å±•å¼€åçš„æŒ‰é’®å³å¯¹é½ */
        .message-item.user .expanded-actions {
            justify-content: flex-end;
        }

        .collapse-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 10px;
            background: rgba(255, 0, 0, 0.1);
            color: #666;
            transition: all 0.2s;
            height: 28px;
            box-sizing: border-box;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .collapse-btn:hover {
            background: rgba(255, 0, 0, 0.2);
        }
        
        .action-btn {
            padding: 2px 6px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 9px;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            background: rgba(0, 0, 0, 0.1);
            color: #666;
            height: 20px;
            box-sizing: border-box;
        }
        
        .action-btn:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        /* æ€è€ƒçŠ¶æ€æ ·å¼ */
        .thinking-message {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .thinking-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            flex-shrink: 0;
            animation: shimmer-pulse 1.2s ease-in-out infinite;
        }

        .thinking-text {
            animation: shimmer-pulse 1.2s ease-in-out infinite;
            font-weight: 500;
        }

        @keyframes shimmer-pulse {
            0%, 100% {
                opacity: 0.5;
            }
            50% {
                opacity: 1;
            }
        }

        /* æ€è€ƒåŠ¨ç”» */
        .thinking-animation {
            animation: thinking 1.5s ease-in-out infinite;
        }

        @keyframes thinking {
            0%, 100% {
                opacity: 0.5;
            }
            50% {
                opacity: 1;
            }
        }

        /* åŠ è½½çŠ¶æ€çš„æ¶ˆæ¯æ°”æ³¡ */
        .message-bubble.loading {
            position: relative;
            overflow: hidden;
        }

        .message-bubble.loading::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.2),
                transparent
            );
            animation: loading-shimmer 1.5s infinite;
        }

        @keyframes loading-shimmer {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }





        /* HTML iframeå®¹å™¨ - çº¯ç²¹çš„åŒ…è£…å®¹å™¨ï¼Œæ— ä»»ä½•æ ·å¼ */
        .html-iframe-container {
            width: 100%;
            /* å®Œå…¨è‡ªé€‚åº”ï¼Œæ— ä»»ä½•é™åˆ¶ */
        }

        /* HTML iframe - å®Œå…¨è‡ªé€‚åº”é«˜åº¦ */
        .html-iframe {
            width: 100%;
            max-width: 100%;
            height: auto;         /* è‡ªé€‚åº”é«˜åº¦ */
            border: none;
            background: transparent !important;
            display: block;
            margin: 0;
            padding: 0;
            overflow: hidden;     /* ä¸æ˜¾ç¤ºæ»šåŠ¨æ¡ï¼Œå®Œå…¨å±•ç¤ºå†…å®¹ */
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        /* åµŒå¥—iframe - åœ¨æ°”æ³¡å†…çš„iframeï¼Œçœ‹èµ·æ¥å¤©ç„¶ */
        .nested-iframe {
            width: 100%;
            max-width: 100%;
            height: auto;           /* è‡ªåŠ¨é«˜åº¦ */
            min-height: 100px;      /* æœ€å°é«˜åº¦ */
            border: none;           /* å»æ‰è¾¹æ¡† */
            background: transparent;
            display: block;
            margin: 0;              /* å»æ‰è¾¹è· */
            padding: 0;
            overflow: hidden;       /* é˜²æ­¢æ»šåŠ¨æ¡ */
        }

        /* æ··åˆå†…å®¹æ ·å¼ - ç»§æ‰¿æ°”æ³¡æ ·å¼ */
        .mixed-content {
            /* ç»§æ‰¿çˆ¶å…ƒç´ çš„æ–‡å­—é¢œè‰²å’Œå­—ä½“ */
            color: inherit;
            font-size: inherit;
            font-family: inherit;
            line-height: inherit;

            /* é˜²æ­¢å†…å®¹æº¢å‡º */
            overflow: hidden;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* æ··åˆå†…å®¹ä¸­çš„ä»£ç å—æ ·å¼ */
        .mixed-content code {
            background: rgba(0, 0, 0, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        /* æ··åˆå†…å®¹ä¸­çš„æ‰€æœ‰å…ƒç´  - å½»åº•å»æ‰æ‰€æœ‰é—´è· */
        .mixed-content * {
            margin: 0 !important;
            padding: 0 !important;
        }

        /* æ··åˆå†…å®¹é»˜è®¤ç»§æ‰¿æ°”æ³¡é¢œè‰²ï¼ŒJavaScriptä¼šå¤„ç†å…·ä½“çš„é¢œè‰²è®¾ç½® */

        /* åªä¿ç•™åˆ—è¡¨çš„å·¦è¾¹è·ç”¨äºç¼–å·/ç¬¦å· */
        .mixed-content ul,
        .mixed-content ol {
            padding-left: 20px !important;
            overflow: hidden;
        }

        /* ä¿ç•™å¿…è¦çš„åŠŸèƒ½æ ·å¼ */
        .mixed-content li {
            word-wrap: break-word;
            overflow-wrap: break-word;
            list-style-position: inside; /* ç¡®ä¿ç¼–å·åœ¨å†…éƒ¨ */
        }

        .mixed-content summary {
            cursor: pointer;
            word-wrap: break-word;
            overflow-wrap: break-word;
            outline: none;
            display: block; /* ç¡®ä¿å—çº§æ˜¾ç¤º */
        }

        .mixed-content details {
            overflow: hidden;
        }

    </style>
</head>
<body>
    <div id="app">
        <div class="chat-container">
            <div
                v-for="message in messages"
                :key="message.msgId"
                :class="['message-item', message.isUser ? 'user' : 'ai']"
                :data-msg-id="message.msgId"
            >
                <!-- HTMLå†…å®¹ç‹¬ç«‹æ¸²æŸ“ï¼ˆæ‡’åŠ è½½ï¼‰ -->
                <div
                    v-if="!message.isLoading && !message.status && isHtmlContent(message.content) && isMessageVisible(message.msgId)"
                    class="html-iframe-container"
                >
                    <iframe
                        :srcdoc="createIsolatedHtml(message.content)"
                        class="html-iframe"
                        frameborder="0"
                        @load="resizeIframe"
                    ></iframe>
                </div>

                <!-- å ä½ç¬¦ï¼ˆæœªåŠ è½½çš„HTMLå†…å®¹ï¼‰ -->
                <div
                    v-else-if="!message.isLoading && !message.status && isHtmlContent(message.content)"
                    class="message-placeholder"
                    :style="{ minHeight: '200px', display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#999' }"
                >
                    HTMLå†…å®¹åŠ è½½ä¸­...
                </div>

                <!-- æ™®é€šæ¶ˆæ¯æ°”æ³¡ -->
                <div
                    v-else
                    :class="['message-bubble', { 'loading': message.isLoading || message.status === 'streaming' }]"
                    :style="{
                        backgroundColor: message.isUser
                            ? hexToRgba(message.userBubbleColor, message.userBubbleOpacity)
                            : hexToRgba(message.bubbleColor, message.bubbleOpacity),
                        color: message.isUser ? message.userTextColor : message.textColor,
                        fontSize: message.fontSize + 'px'
                    }"
                >
                    <!-- æ¶ˆæ¯å†…å®¹æ˜¾ç¤º -->
                    <div class="message-content">
                        <!-- æ€è€ƒçŠ¶æ€æ˜¾ç¤º -->
                        <div v-if="message.isLoading || message.status === 'streaming'" class="thinking-message">
                            <div
                                class="thinking-dot"
                                :style="{ backgroundColor: message.isUser ? message.userTextColor : message.textColor }"
                            ></div>
                            <span
                                class="thinking-text"
                                :style="{ color: message.isUser ? message.userTextColor : message.textColor }"
                            >
                                æ­£åœ¨ç”Ÿæˆ...
                            </span>
                        </div>

                        <!-- æ¶ˆæ¯å†…å®¹ -->
                        <template v-else>
                            <!-- æ··åˆå†…å®¹ï¼šHTMLæ ‡ç­¾+æ–‡æœ¬ï¼Œåœ¨æ°”æ³¡å†…ç”¨iframeæ¸²æŸ“ï¼ˆæ‡’åŠ è½½ï¼‰ -->
                            <iframe
                                v-if="hasMixedContent(message.content) && isMessageVisible(message.msgId)"
                                :srcdoc="createColoredIsolatedHtml(message.content, message.isUser ? message.userTextColor : message.textColor)"
                                class="nested-iframe"
                                frameborder="0"
                                @load="resizeIframe"
                            ></iframe>

                            <!-- å ä½ç¬¦ï¼ˆæœªåŠ è½½çš„æ··åˆå†…å®¹ï¼‰ -->
                            <div
                                v-else-if="hasMixedContent(message.content)"
                                class="mixed-placeholder"
                                :style="{ minHeight: '50px', display: 'flex', alignItems: 'center', justifyContent: 'center', opacity: 0.7 }"
                            >
                                å†…å®¹åŠ è½½ä¸­...
                            </div>

                            <!-- çº¯æ–‡æœ¬å†…å®¹ -->
                            <template v-else>
                                {{ message.content }}
                            </template>
                        </template>
                    </div>
                </div>

                <!-- æ“ä½œæŒ‰é’®ï¼ˆæ€è€ƒçŠ¶æ€æ—¶éšè—ï¼‰ -->
                <div v-if="!message.isLoading && message.status !== 'streaming'" class="message-actions">
                    <!-- AIæ¶ˆæ¯ï¼šå±•å¼€æŒ‰é’®åœ¨å‰ï¼Œæ“ä½œæŒ‰é’®åœ¨å -->
                    <template v-if="!message.isUser">
                        <button
                            class="function-btn"
                            @click="toggleActions(message.msgId)"
                            :style="{
                                backgroundColor: hexToRgba(message.bubbleColor, message.bubbleOpacity),
                                color: message.textColor
                            }"
                        >
                            {{ isActionsExpanded(message.msgId) ? 'æ”¶èµ·' : 'æ“ä½œ' }}
                        </button>

                        <template v-if="isActionsExpanded(message.msgId)">
                            <button
                                class="action-btn"
                                @click="regenerateMessage(message.msgId)"
                                :style="{
                                    backgroundColor: hexToRgba(message.bubbleColor, message.bubbleOpacity),
                                    color: message.textColor
                                }"
                            >
                                ğŸ”„ é‡æ–°ç”Ÿæˆ
                            </button>
                            <button
                                class="action-btn"
                                @click="deleteMessage(message.msgId)"
                                :style="{
                                    backgroundColor: hexToRgba(message.bubbleColor, message.bubbleOpacity),
                                    color: message.textColor
                                }"
                            >
                                ğŸ—‘ï¸ åˆ é™¤
                            </button>
                            <button
                                class="action-btn"
                                @click="copyMessage(message.originalContent || message.content)"
                                :style="{
                                    backgroundColor: hexToRgba(message.bubbleColor, message.bubbleOpacity),
                                    color: message.textColor
                                }"
                            >
                                ğŸ“‹ å¤åˆ¶
                            </button>
                            <button
                                class="action-btn"
                                @click="editMessage(message.msgId, message.originalContent || message.content)"
                                :style="{
                                    backgroundColor: hexToRgba(message.bubbleColor, message.bubbleOpacity),
                                    color: message.textColor
                                }"
                            >
                                âœï¸ ç¼–è¾‘
                            </button>
                        </template>
                    </template>

                    <!-- ç”¨æˆ·æ¶ˆæ¯ï¼šæ“ä½œæŒ‰é’®åœ¨å‰ï¼Œå±•å¼€æŒ‰é’®åœ¨å -->
                    <template v-else>
                        <template v-if="isActionsExpanded(message.msgId)">
                            <button
                                class="action-btn"
                                @click="revokeMessage(message.msgId)"
                                :style="{
                                    backgroundColor: hexToRgba(message.userBubbleColor, message.userBubbleOpacity),
                                    color: message.userTextColor
                                }"
                            >
                                â†©ï¸ æ’¤é”€
                            </button>
                            <button
                                class="action-btn"
                                @click="deleteMessage(message.msgId)"
                                :style="{
                                    backgroundColor: hexToRgba(message.userBubbleColor, message.userBubbleOpacity),
                                    color: message.userTextColor
                                }"
                            >
                                ğŸ—‘ï¸ åˆ é™¤
                            </button>
                            <button
                                class="action-btn"
                                @click="copyMessage(message.originalContent || message.content)"
                                :style="{
                                    backgroundColor: hexToRgba(message.userBubbleColor, message.userBubbleOpacity),
                                    color: message.userTextColor
                                }"
                            >
                                ğŸ“‹ å¤åˆ¶
                            </button>
                            <button
                                class="action-btn"
                                @click="editMessage(message.msgId, message.originalContent || message.content)"
                                :style="{
                                    backgroundColor: hexToRgba(message.userBubbleColor, message.userBubbleOpacity),
                                    color: message.userTextColor
                                }"
                            >
                                âœï¸ ç¼–è¾‘
                            </button>
                        </template>

                        <button
                            class="function-btn"
                            @click="toggleActions(message.msgId)"
                            :style="{
                                backgroundColor: hexToRgba(message.userBubbleColor, message.userBubbleOpacity),
                                color: message.userTextColor
                            }"
                        >
                            {{ isActionsExpanded(message.msgId) ? 'æ”¶èµ·' : 'æ“ä½œ' }}
                        </button>
                    </template>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, nextTick } = Vue;
        
        createApp({
            setup() {
                const messages = ref([]);
                const expandedActions = ref(new Set()); // å­˜å‚¨å±•å¼€çš„æ¶ˆæ¯ID
                const visibleMessages = ref(new Set()); // å­˜å‚¨å¯è§çš„æ¶ˆæ¯ID

                // å°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸ºå¸¦é€æ˜åº¦çš„rgba
                const hexToRgba = (hex, opacity) => {
                    // ç§»é™¤#å·
                    hex = hex.replace('#', '');

                    // è§£æRGBå€¼
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);

                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                };

                // æ£€æµ‹å†…å®¹æ˜¯å¦éœ€è¦iframeç‹¬ç«‹æ¸²æŸ“ï¼ˆå¤æ‚HTMLï¼‰
                const isComplexHtmlContent = (content) => {
                    if (!content || typeof content !== 'string') return false;

                    const trimmed = content.trim().toLowerCase();

                    // å®Œæ•´çš„HTMLæ–‡æ¡£ä½¿ç”¨iframe
                    if (trimmed.startsWith('<!doctype html') || trimmed.startsWith('<html')) {
                        return true;
                    }

                    // æˆ–è€…åŒ…å«headå’Œbodyæ ‡ç­¾çš„å®Œæ•´ç»“æ„
                    if (trimmed.includes('<head') && trimmed.includes('<body')) {
                        return true;
                    }

                    return false;
                };

                // æ£€æµ‹å†…å®¹æ˜¯å¦åŒ…å«ç®€å•HTMLæ ‡ç­¾ï¼ˆåœ¨æ°”æ³¡å†…æ¸²æŸ“ï¼‰
                const hasSimpleHtmlContent = (content) => {
                    if (!content || typeof content !== 'string') return false;

                    // å¦‚æœæ˜¯å¤æ‚HTMLï¼Œä¸ç®—ç®€å•å†…å®¹
                    if (isComplexHtmlContent(content)) return false;

                    // æ£€æµ‹æ˜¯å¦åŒ…å«HTMLæ ‡ç­¾ï¼Œå¦‚æœåŒ…å«å°±åœ¨æ°”æ³¡å†…æ¸²æŸ“
                    const htmlTagRegex = /<[^>]+>/;
                    return htmlTagRegex.test(content);
                };

                // ä¸ºäº†å…¼å®¹æ€§ï¼Œä¿ç•™åŸæ¥çš„å‡½æ•°å
                const isHtmlContent = isComplexHtmlContent;
                const hasMixedContent = hasSimpleHtmlContent;

                // æœ¬åœ°æ¸²æŸ“ï¼Œä¸éœ€è¦æ¸…ç†HTMLå†…å®¹
                const sanitizeHtml = (content) => {
                    // ç›´æ¥è¿”å›åŸå§‹å†…å®¹ï¼Œæ”¯æŒæ‰€æœ‰HTMLæ ‡ç­¾å’ŒåŠŸèƒ½
                    return content;
                };

                // ç®€å•çš„HTMLå†…å®¹ç¼“å­˜
                const htmlCache = new Map();
                const maxCacheSize = 20; // æœ€å¤§ç¼“å­˜20ä¸ª

                // åˆ›å»ºéš”ç¦»çš„HTMLæ–‡æ¡£ï¼ˆç”¨äºç‹¬ç«‹iframeï¼‰
                const createIsolatedHtml = (content) => {
                    const cacheKey = `isolated_${content.length}_${content.substring(0, 50)}`;

                    // æ£€æŸ¥ç¼“å­˜
                    if (htmlCache.has(cacheKey)) {
                        return htmlCache.get(cacheKey);
                    }

                    // æ£€æµ‹æ˜¯å¦ä¸ºå®Œæ•´çš„HTMLæ–‡æ¡£
                    const trimmed = content.trim().toLowerCase();
                    const isFullHtml = trimmed.startsWith('<!doctype html') || 
                                     trimmed.startsWith('<html') || 
                                     (trimmed.includes('<head') && trimmed.includes('<body>'));

                    let html;
                    
                    if (isFullHtml) {
                        // å¦‚æœæ˜¯å®Œæ•´çš„HTMLæ–‡æ¡£ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å†…å®¹
                        html = content;
                    } else {
                        // å¯¹äºéå®Œæ•´HTMLï¼Œä½¿ç”¨åŸæ¥çš„åŒ…è£…æ–¹å¼
                        html = `
                            <!DOCTYPE html>
                            <html style="background: transparent !important;">
                            <head>
                                <meta charset="UTF-8">
                                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                                <style>
                                    html, body {
                                        margin: 0;
                                        padding: 0;
                                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                        font-size: 14px;
                                        line-height: 1.5;
                                        background: transparent !important;
                                        backdrop-filter: none !important;
                                        -webkit-backdrop-filter: none !important;
                                        overflow: auto;
                                    }

                                    /* ç¡®ä¿å†…å®¹é€‚åº”iframeå®½åº¦ */
                                    .terminal {
                                        max-width: 100% !important;
                                        width: 100% !important;
                                        margin: 0 !important;
                                    }

                                    /* éšè—æ»šåŠ¨æ¡ä½†ä¿ç•™æ»šåŠ¨åŠŸèƒ½ */
                                    ::-webkit-scrollbar {
                                        display: none;
                                    }
                                    * {
                                        scrollbar-width: none;
                                        -ms-overflow-style: none;
                                    }
                                </style>
                            </head>
                            <body>
                                ${content}

                                <script>
                                    function resizeParent() {
                                        const height = document.body.scrollHeight;
                                        window.parent.postMessage({
                                            type: 'resize',
                                            height: height
                                        }, '*');
                                    }

                                    window.addEventListener('load', function() {
                                        resizeParent();
                                    });

                                    // ç›‘å¬é«˜åº¦å˜åŒ–
                                    const observer = new MutationObserver(function() {
                                        resizeParent();
                                    });
                                    observer.observe(document.body, {
                                        childList: true,
                                        subtree: true,
                                        attributes: true
                                    });

                                    setTimeout(function() {
                                        resizeParent();
                                    }, 100);
                                <\/script>
                            </body>
                            </html>
                        `;
                    }

                    // ç¼“å­˜ç»“æœ
                    if (htmlCache.size >= maxCacheSize) {
                        const firstKey = htmlCache.keys().next().value;
                        htmlCache.delete(firstKey);
                    }
                    htmlCache.set(cacheKey, html);

                    return html;
                };

                // åˆ›å»ºå¸¦é¢œè‰²çš„éš”ç¦»HTMLæ–‡æ¡£ï¼ˆç”¨äºåµŒå¥—iframeï¼‰
                const createColoredIsolatedHtml = (content, textColor) => {
                    const cacheKey = `colored_${content.length}_${textColor}_${content.substring(0, 50)}`;

                    // æ£€æŸ¥ç¼“å­˜
                    if (htmlCache.has(cacheKey)) {
                        return htmlCache.get(cacheKey);
                    }

                    const html = `
                        <!DOCTYPE html>
                        <html style="background: transparent !important;">
                        <head>
                            <meta charset="UTF-8">
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                            <style>
                                html, body {
                                    margin: 0;
                                    padding: 0;
                                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                    font-size: 14px;
                                    line-height: 1.5;
                                    background: transparent !important;
                                    backdrop-filter: none !important;
                                    -webkit-backdrop-filter: none !important;
                                    overflow-x: auto;
                                    overflow-y: hidden;
                                    color: ${textColor} !important;
                                }

                                /* ç¡®ä¿æ‰€æœ‰å…ƒç´ é»˜è®¤ç»§æ‰¿æ–‡æœ¬é¢œè‰² */
                                * {
                                    color: inherit;
                                }

                                /* ç¡®ä¿å†…å®¹é€‚åº”iframeå®½åº¦ */
                                .terminal {
                                    max-width: 100% !important;
                                    width: 100% !important;
                                    margin: 0 !important;
                                }

                                /* éšè—æ»šåŠ¨æ¡ä½†ä¿ç•™æ»šåŠ¨åŠŸèƒ½ */
                                ::-webkit-scrollbar {
                                    display: none;
                                }
                                * {
                                    scrollbar-width: none;
                                    -ms-overflow-style: none;
                                }
                            </style>
                        </head>
                        <body>
                            ${content}

                            <script>
                                function resizeParent() {
                                    const height = document.body.scrollHeight;
                                    window.parent.postMessage({
                                        type: 'resize',
                                        height: height
                                    }, '*');
                                }

                                window.addEventListener('load', function() {
                                    resizeParent();
                                });

                                // ç›‘å¬é«˜åº¦å˜åŒ–
                                const observer = new MutationObserver(function() {
                                    resizeParent();
                                });
                                observer.observe(document.body, {
                                    childList: true,
                                    subtree: true,
                                    attributes: true
                                });

                                setTimeout(function() {
                                    resizeParent();
                                }, 100);
                            <\/script>
                        </body>
                        </html>
                    `;

                    // ç¼“å­˜ç»“æœ
                    if (htmlCache.size >= maxCacheSize) {
                        const firstKey = htmlCache.keys().next().value;
                        htmlCache.delete(firstKey);
                    }
                    htmlCache.set(cacheKey, html);

                    return html;
                };

                // iframeè‡ªåŠ¨è°ƒæ•´å¤§å°
                const resizeIframe = (event) => {
                    const iframe = event.target;
                    const isNested = iframe.classList.contains('nested-iframe');

                    // ç‹¬ç«‹iframeï¼šå®Œå…¨è‡ªé€‚åº”é«˜åº¦ï¼Œæ— ä»»ä½•é™åˆ¶
                    if (!isNested) {
                        setTimeout(() => {
                            try {
                                const doc = iframe.contentDocument || iframe.contentWindow.document;
                                if (doc && doc.body) {
                                    const contentHeight = doc.body.scrollHeight;
                                    // ç›´æ¥è®¾ç½®iframeé«˜åº¦ä¸ºå†…å®¹é«˜åº¦ï¼Œæ— ä»»ä½•é™åˆ¶
                                    iframe.style.height = contentHeight + 'px';
                                }
                            } catch (e) {
                                // å¦‚æœæ— æ³•è®¿é—®ï¼Œä½¿ç”¨é»˜è®¤é«˜åº¦
                                iframe.style.height = '400px';
                            }
                        }, 100);
                        return;
                    }

                    // åµŒå¥—iframeä¿æŒåŸæœ‰çš„è‡ªé€‚åº”é€»è¾‘
                    const handleMessage = (e) => {
                        if (e.source === iframe.contentWindow && e.data && e.data.type === 'resize') {
                            const newHeight = e.data.height;
                            iframe.style.height = newHeight + 'px';
                        }
                    };

                    window.addEventListener('message', handleMessage);

                    // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
                    iframe.addEventListener('beforeunload', () => {
                        window.removeEventListener('message', handleMessage);
                    });
                };
                // å‘é€æ¶ˆæ¯åˆ°Flutter
                const sendToFlutter = (action, data = {}) => {
                    console.log('Sending to Flutter:', action, data);
                    if (window.FlutterBridge) {
                        window.FlutterBridge.postMessage(JSON.stringify({
                            action: action,
                            ...data
                        }));
                    } else {
                        console.error('FlutterBridge not available');
                    }
                };
                
                // ========== HTMLæ¨¡æ¿æ¸²æŸ“ç›¸å…³ ==========
                
                // æ¨¡æ¿ç¼“å­˜ï¼ˆtemplateId -> htmlTemplateï¼‰
                const templateCache = new Map();
                
                // ç­‰å¾…æ¨¡æ¿çš„ Promise ç¼“å­˜ï¼ˆtemplateId -> Promiseï¼‰
                const templatePromises = new Map();
                
                // ä» Flutter æ¥æ”¶æ¨¡æ¿çš„å›è°ƒ
                window.receiveTemplate = (response) => {
                    console.log('[HTML] æ”¶åˆ°æ¨¡æ¿å“åº”:', response);
                    const { templateId, htmlTemplate, error } = response;
                    
                    if (error) {
                        console.error('[HTML] è·å–æ¨¡æ¿å¤±è´¥:', error);
                        // ç¼“å­˜å¤±è´¥ç»“æœï¼Œé¿å…é‡å¤è¯·æ±‚
                        templateCache.set(templateId, null);
                    } else {
                        // ç¼“å­˜æ¨¡æ¿
                        templateCache.set(templateId, htmlTemplate);
                    }
                    
                    // è§£å†³ç­‰å¾…çš„ Promise
                    const resolve = templatePromises.get(templateId);
                    if (resolve) {
                        resolve(htmlTemplate || null);
                        templatePromises.delete(templateId);
                    }
                };
                
                // ä» Flutter è·å–æ¨¡æ¿
                const getTemplate = (templateId) => {
                    // æ£€æŸ¥ç¼“å­˜
                    if (templateCache.has(templateId)) {
                        return Promise.resolve(templateCache.get(templateId));
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰pendingçš„è¯·æ±‚
                    if (templatePromises.has(templateId)) {
                        return new Promise((resolve) => {
                            // å¤šä¸ªè¯·æ±‚å…±äº«åŒä¸€ä¸ªPromise
                            const existingResolve = templatePromises.get(templateId);
                            templatePromises.set(templateId, (result) => {
                                existingResolve(result);
                                resolve(result);
                            });
                        });
                    }
                    
                    // åˆ›å»ºæ–°çš„Promise
                    return new Promise((resolve) => {
                        templatePromises.set(templateId, resolve);
                        
                        // å‘ Flutter è¯·æ±‚æ¨¡æ¿
                        sendToFlutter('getTemplate', { templateId });
                        
                        // è®¾ç½®è¶…æ—¶ï¼ˆ5ç§’ï¼‰
                        setTimeout(() => {
                            if (templatePromises.has(templateId)) {
                                console.error('[HTML] è·å–æ¨¡æ¿è¶…æ—¶:', templateId);
                                templatePromises.delete(templateId);
                                templateCache.set(templateId, null);
                                resolve(null);
                            }
                        }, 5000);
                    });
                };
                
                // æå–æ¶ˆæ¯ä¸­çš„æ¨¡æ¿JSON
                const extractTemplateJson = (content) => {
                    const matches = [];
                    
                    // 1. å…ˆåŒ¹é… ```json ... ``` ä»£ç å—
                    const markdownRegex = /```json\s*\n([\s\S]*?)\n```/g;
                    let match;
                    
                    while ((match = markdownRegex.exec(content)) !== null) {
                        try {
                            const jsonStr = match[1].trim();
                            const jsonData = JSON.parse(jsonStr);
                            
                            // æ£€æŸ¥æ˜¯å¦åŒ…å« template_id æˆ– templateId
                            if (jsonData.template_id || jsonData.templateId) {
                                matches.push({
                                    original: match[0], // å®Œæ•´åŒ¹é…ï¼ˆåŒ…å« ```json ... ```ï¼‰
                                    json: jsonData
                                });
                            }
                        } catch (e) {
                            console.warn('[HTML] Markdownä»£ç å—JSONè§£æå¤±è´¥:', e);
                        }
                    }
                    
                    // 2. æå–çº¯ JSONï¼ˆä¸åœ¨ä»£ç å—ä¸­çš„ï¼‰
                    // å…ˆç§»é™¤å·²åŒ¹é…çš„ä»£ç å—ï¼Œé¿å…é‡å¤åŒ¹é…
                    let remainingContent = content;
                    for (const item of matches) {
                        remainingContent = remainingContent.replace(item.original, '');
                    }
                    
                    // ä½¿ç”¨æ‹¬å·åŒ¹é…ç®—æ³•æå–å®Œæ•´çš„ JSON å¯¹è±¡
                    for (let i = 0; i < remainingContent.length; i++) {
                        if (remainingContent[i] === '{') {
                            // æ‰¾åˆ°å·¦æ‹¬å·ï¼Œå¼€å§‹åŒ¹é…
                            let depth = 1;
                            let j = i + 1;
                            let inString = false;
                            let escapeNext = false;
                            
                            while (j < remainingContent.length && depth > 0) {
                                const char = remainingContent[j];
                                
                                if (escapeNext) {
                                    escapeNext = false;
                                } else if (char === '\\') {
                                    escapeNext = true;
                                } else if (char === '"' && !escapeNext) {
                                    inString = !inString;
                                } else if (!inString) {
                                    if (char === '{') {
                                        depth++;
                                    } else if (char === '}') {
                                        depth--;
                                    }
                                }
                                j++;
                            }
                            
                            // å¦‚æœæ‰¾åˆ°äº†å®Œæ•´çš„ JSON å¯¹è±¡
                            if (depth === 0) {
                                const jsonStr = remainingContent.substring(i, j);
                                try {
                                    const jsonData = JSON.parse(jsonStr);
                                    
                                    // å¿…é¡»æ˜¯å¯¹è±¡ï¼Œä¸”åŒ…å« template_id æˆ– templateId
                                    if (typeof jsonData === 'object' && 
                                        jsonData !== null && 
                                        (jsonData.template_id || jsonData.templateId)) {
                                        matches.push({
                                            original: jsonStr,
                                            json: jsonData
                                        });
                                    }
                                } catch (e) {
                                    // JSON è§£æå¤±è´¥ï¼Œè·³è¿‡
                                }
                                
                                // è·³è¿‡å·²åŒ¹é…çš„éƒ¨åˆ†
                                i = j - 1;
                            }
                        }
                    }
                    
                    return matches;
                };
                
                // æ¸²æŸ“æ¨¡æ¿
                const renderTemplate = (htmlTemplate, data) => {
                    if (!htmlTemplate || !data) {
                        return htmlTemplate;
                    }
                    
                    let rendered = htmlTemplate;
                    
                    // æ›¿æ¢æ‰€æœ‰ {{key}} å ä½ç¬¦
                    for (const [key, value] of Object.entries(data)) {
                        const placeholder = `{{${key}}}`;
                        const regex = new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                        rendered = rendered.replace(regex, value !== null && value !== undefined ? String(value) : '');
                    }
                    
                    return rendered;
                };
                
                // å¤„ç†æ¶ˆæ¯ä¸­çš„æ¨¡æ¿
                const processMessageTemplates = async (message) => {
                    const content = message.content;
                    if (!content || typeof content !== 'string') {
                        return message;
                    }
                    
                    // æå–æ‰€æœ‰æ¨¡æ¿JSON
                    const templates = extractTemplateJson(content);
                    if (templates.length === 0) {
                        return message;
                    }
                    
                    console.log(`[HTML] åœ¨æ¶ˆæ¯ä¸­æ‰¾åˆ° ${templates.length} ä¸ªæ¨¡æ¿`);
                    
                    let processedContent = content;
                    
                    // é€ä¸ªå¤„ç†æ¨¡æ¿
                    for (const template of templates) {
                        const templateId = template.json.template_id || template.json.templateId;
                        const data = template.json.data;
                        
                        console.log('[HTML] å¤„ç†æ¨¡æ¿ID:', templateId);
                        
                        // è·å–æ¨¡æ¿
                        const htmlTemplate = await getTemplate(templateId);
                        
                        if (htmlTemplate) {
                            // æ¸²æŸ“æ¨¡æ¿
                            const renderedHtml = renderTemplate(htmlTemplate, data);
                            console.log('[HTML] æ¸²æŸ“æˆåŠŸï¼ŒHTMLé•¿åº¦:', renderedHtml.length);
                            
                            // æ›¿æ¢åŸå§‹JSONä¸ºæ¸²æŸ“åçš„HTML
                            processedContent = processedContent.replace(template.original, renderedHtml);
                        } else {
                            console.warn('[HTML] æ¨¡æ¿ä¸å­˜åœ¨æˆ–è·å–å¤±è´¥:', templateId);
                        }
                    }
                    
                    // è¿”å›å¤„ç†åçš„æ¶ˆæ¯ï¼Œä¿ç•™åŸå§‹å†…å®¹ç”¨äºç¼–è¾‘
                    return {
                        ...message,
                        originalContent: content,  // ä¿å­˜åŸå§‹å†…å®¹
                        content: processedContent  // æ¸²æŸ“åçš„å†…å®¹ç”¨äºæ˜¾ç¤º
                    };
                };
                
                // ========== æ›´æ–°æ¶ˆæ¯åˆ—è¡¨ ==========
                
                // æ›´æ–°æ¶ˆæ¯åˆ—è¡¨
                const updateMessages = async (newMessages, shouldScrollToBottom = false) => {
                    // å…ˆå¤„ç†æ‰€æœ‰æ¶ˆæ¯ä¸­çš„æ¨¡æ¿
                    const processedMessages = await Promise.all(
                        newMessages.map(msg => processMessageTemplates(msg))
                    );
                    
                    const oldLength = messages.value.length;
                    const newLength = processedMessages.length;

                    // å¦‚æœæ˜¯åˆå§‹åŠ è½½ï¼ˆä»0æ¡æ¶ˆæ¯å¼€å§‹ï¼‰ï¼Œå»¶è¿Ÿæ»šåŠ¨åˆ°åº•éƒ¨
                    if (oldLength === 0 && newLength > 0) {
                        messages.value = processedMessages;
                        setTimeout(() => {
                            window.scrollTo(0, document.body.scrollHeight);
                        }, 0);
                        return;
                    }

                    // å¦‚æœæ˜¯åˆ†é¡µåŠ è½½ï¼ˆå†å²æ¶ˆæ¯å¢åŠ ï¼‰ï¼Œè®°å½•å½“å‰æ»šåŠ¨ä½ç½®
                    let shouldMaintainPosition = false;
                    let oldScrollHeight = 0;

                    if (newLength > oldLength && !shouldScrollToBottom) {
                        shouldMaintainPosition = true;
                        oldScrollHeight = document.documentElement.scrollHeight;
                    }

                    messages.value = processedMessages;

                    // å¤„ç†æ»šåŠ¨ä½ç½®
                    if (shouldScrollToBottom) {
                        scrollToBottom();
                    } else if (shouldMaintainPosition) {
                        // ä½¿ç”¨ nextTick ç¡®ä¿ DOM å®Œå…¨æ›´æ–°åå†è°ƒæ•´æ»šåŠ¨ä½ç½®
                        Vue.nextTick(() => {
                            const newScrollHeight = document.documentElement.scrollHeight;
                            const heightDiff = newScrollHeight - oldScrollHeight;
                            window.scrollTo({
                                top: window.scrollY + heightDiff,
                                behavior: 'instant'
                            });
                        });
                    }
                };

                // æ»šåŠ¨åˆ°åº•éƒ¨ï¼ˆæœ€æ–°æ¶ˆæ¯ä½ç½®ï¼‰
                const scrollToBottom = () => {
                    // ç”±äºä½¿ç”¨äº†column-reverseï¼Œéœ€è¦æ»šåŠ¨åˆ°é¡µé¢åº•éƒ¨
                    window.scrollTo({
                        top: document.documentElement.scrollHeight,
                        behavior: 'instant' // ç«‹å³æ»šåŠ¨ï¼Œä¸è¦åŠ¨ç”»
                    });
                };

                // æ»šåŠ¨ç›‘å¬ï¼Œå®ç°åˆ†é¡µåŠ è½½
                const handleScroll = () => {
                    // æ£€æŸ¥æ˜¯å¦æ»šåŠ¨åˆ°é¡¶éƒ¨ï¼ˆéœ€è¦åŠ è½½æ›´å¤šå†å²æ¶ˆæ¯ï¼‰
                    if (window.scrollY <= 100) { // è·ç¦»é¡¶éƒ¨100pxæ—¶è§¦å‘
                        sendToFlutter('loadMore', {});
                    }
                };

                // æ·»åŠ æ»šåŠ¨ç›‘å¬
                window.addEventListener('scroll', handleScroll);
                
                // ç¼–è¾‘æ¶ˆæ¯ - è°ƒç”¨FlutteråŸç”Ÿç¼–è¾‘é¡µé¢
                const editMessage = (msgId, content) => {
                    sendToFlutter('editMessage', { msgId, content });
                };

                // å¤åˆ¶æ¶ˆæ¯
                const copyMessage = (content) => {
                    sendToFlutter('copyMessage', { content });
                };

                // åˆ é™¤æ¶ˆæ¯
                const deleteMessage = (msgId) => {
                    sendToFlutter('deleteMessage', { msgId });
                };

                // æ’¤é”€æ¶ˆæ¯
                const revokeMessage = (msgId) => {
                    sendToFlutter('revokeMessage', { msgId });
                };

                // é‡æ–°ç”Ÿæˆæ¶ˆæ¯
                const regenerateMessage = (msgId) => {
                    sendToFlutter('regenerateMessage', { msgId });
                };

                // åˆ‡æ¢æ“ä½œæŒ‰é’®çš„å±•å¼€/æ”¶èµ·çŠ¶æ€
                const toggleActions = (msgId) => {
                    if (expandedActions.value.has(msgId)) {
                        expandedActions.value.delete(msgId);
                    } else {
                        expandedActions.value.add(msgId);
                    }
                    // è§¦å‘å“åº”å¼æ›´æ–°
                    expandedActions.value = new Set(expandedActions.value);
                };

                // æ£€æŸ¥æ“ä½œæŒ‰é’®æ˜¯å¦å±•å¼€
                const isActionsExpanded = (msgId) => {
                    return expandedActions.value.has(msgId);
                };

                // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦å¯è§ï¼ˆæš‚æ—¶å…¨éƒ¨å¯è§ï¼‰
                const isMessageVisible = (msgId) => {
                    return true; // æš‚æ—¶å…¨éƒ¨æ˜¾ç¤º
                };

                // åº”ç”¨æ··åˆå†…å®¹æ ·å¼ï¼Œç¡®ä¿æ²¡æœ‰é¢œè‰²è®¾ç½®çš„å…ƒç´ ç»§æ‰¿æ°”æ³¡é¢œè‰²
                const applyMixedContentStyles = (element, message) => {
                    if (!element) return;

                    const textColor = message.isUser ? message.userTextColor : message.textColor;

                    // é€’å½’å¤„ç†æ‰€æœ‰å­å…ƒç´ 
                    const processElement = (el) => {
                        if (el.nodeType === Node.ELEMENT_NODE) {
                            // æ£€æŸ¥å…ƒç´ æ˜¯å¦æœ‰æ˜ç¡®çš„é¢œè‰²è®¾ç½®
                            const hasColorStyle = el.style.color || el.getAttribute('color');

                            if (!hasColorStyle) {
                                // æ²¡æœ‰é¢œè‰²è®¾ç½®ï¼Œä½¿ç”¨æ°”æ³¡é¢œè‰²
                                el.style.color = textColor;
                            }

                            // é€’å½’å¤„ç†å­å…ƒç´ 
                            for (let child of el.children) {
                                processElement(child);
                            }
                        }
                    };

                    // å¤„ç†æ··åˆå†…å®¹å®¹å™¨çš„æ‰€æœ‰å­å…ƒç´ 
                    for (let child of element.children) {
                        processElement(child);
                    }
                };

                // æš´éœ²ç»™å…¨å±€ï¼Œä¾›Flutterè°ƒç”¨
                window.updateMessages = updateMessages;
                
                return {
                    messages,
                    expandedActions,
                    visibleMessages,
                    hexToRgba,
                    isHtmlContent,
                    hasMixedContent,
                    sanitizeHtml,
                    createIsolatedHtml,
                    createColoredIsolatedHtml,
                    resizeIframe,
                    editMessage,
                    copyMessage,
                    deleteMessage,
                    revokeMessage,
                    regenerateMessage,
                    toggleActions,
                    isActionsExpanded,
                    isMessageVisible,
                    applyMixedContentStyles
                };
            },

        }).mount('#app');
    </script>
</body>
</html>
